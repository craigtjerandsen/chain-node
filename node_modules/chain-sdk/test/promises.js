'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-env mocha */

var chain = require('../dist/index.js');
var uuid = require('uuid');
var assert = require('assert');
var chai = require('chai');
var chaiAsPromised = require('chai-as-promised');
chai.use(chaiAsPromised);

var expect = chai.expect;

// Helper function
var balanceByAssetAlias = function balanceByAssetAlias(balances) {
  var res = {};
  return Promise.resolve(balances).then(function (balance) {
    balance.items.forEach(function (item) {
      res[item.sumBy.assetAlias] = item.amount;
    });
    return res;
  });
};

var client = new chain.Client();
var signer = new chain.HsmSigner();

var aliceAlias = 'alice-' + uuid.v4();
var bobAlias = 'bob-' + uuid.v4();
var goldAlias = 'gold-' + uuid.v4();
var silverAlias = 'silver-' + uuid.v4();
var bronzeAlias = 'bronze-' + uuid.v4();
var copperAlias = 'copper-' + uuid.v4();
var tokenId = 'token-' + uuid.v4();

var aliceKey = void 0,
    bobKey = void 0,
    goldKey = void 0,
    silverKey = void 0,
    otherKey = void 0,
    aliceId = void 0;

var buildSignSubmit = function buildSignSubmit(buildFunc) {
  return client.transactions.build(buildFunc).then(function (tpl) {
    return signer.sign(tpl);
  }).then(function (tpl) {
    return client.transactions.submit(tpl);
  });
};

describe('Promise style', function () {
  before('set up API objects', function () {
    // Key creation and signer setup
    return expect(Promise.all([client.mockHsm.keys.create({ alias: aliceAlias }), client.mockHsm.keys.create({ alias: bobAlias }), client.mockHsm.keys.create({ alias: goldAlias }), client.mockHsm.keys.create({ alias: silverAlias }), client.mockHsm.keys.create({ alias: bronzeAlias }), client.mockHsm.keys.create({ alias: copperAlias }), client.mockHsm.keys.create()])).to.be.fulfilled.then(function (keys) {
      aliceKey = keys[0];
      bobKey = keys[1];
      goldKey = keys[2];
      silverKey = keys[3];
      otherKey = keys[6];

      signer.addKey(aliceKey, client.mockHsm.signerConnection);
      signer.addKey(bobKey, client.mockHsm.signerConnection);
      signer.addKey(goldKey, client.mockHsm.signerConnection);
      signer.addKey(silverKey, client.mockHsm.signerConnection);
    })

    // Account creation

    .then(function () {
      return expect(Promise.all([client.accounts.create({ alias: aliceAlias, rootXpubs: [aliceKey.xpub], quorum: 1 }), client.accounts.create({ alias: bobAlias, rootXpubs: [bobKey.xpub], quorum: 1 })])).to.be.fulfilled;
    }).then(function (accounts) {
      aliceId = accounts[0].id;
    }).then(function () {
      return expect(client.accounts.create({ alias: 'david' }))
      // Request is missing key fields
      .to.be.rejectedWith('CH202');
    })

    // Asset creation

    .then(function () {
      return expect(Promise.all([client.assets.create({ alias: goldAlias, rootXpubs: [goldKey.xpub], quorum: 1 }), client.assets.create({ alias: silverAlias, rootXpubs: [silverKey.xpub], quorum: 1 })])).to.be.fulfilled;
    }).then(function () {
      return expect(client.assets.create({ alias: 'unobtanium' }))
      // Request is missing key fields
      .to.be.rejectedWith('CH202');
    });
  });

  it('works', function () {
    return Promise.resolve()

    // Access tokens

    .then(function () {
      return expect(client.accessTokens.create({
        type: 'client',
        id: tokenId
      })).to.be.fulfilled;
    }).then(function (resp) {
      expect(resp.token).to.not.be.empty;
    }).then(function () {
      return expect(client.accessTokens.create({
        type: 'client',
        id: tokenId
      }))
      // Using same ID twice will trigger a duplicate ID error
      .to.be.rejectedWith('CH302');
    }).then(function () {
      return expect(client.accessTokens.query()).to.be.fulfilled;
    }).then(function (resp) {
      return expect(resp.items.map(function (item) {
        return item.id;
      })).to.contain(tokenId);
    }).then(function () {
      return expect(client.accessTokens.query({ type: 'client' })).to.be.fulfilled;
    }).then(function (resp) {
      return expect(resp.items.map(function (item) {
        return item.id;
      })).to.contain(tokenId);
    }).then(function () {
      return expect(client.accessTokens.query({ type: 'network' })).to.be.fulfilled;
    }).then(function (resp) {
      return expect(resp.items.map(function (item) {
        return item.id;
      })).to.not.contain(tokenId);
    }).then(function () {
      return expect(client.accessTokens.delete(tokenId)).to.be.fulfilled;
    }).then(function () {
      return expect(client.accessTokens.query()).to.be.fulfilled;
    }).then(function (resp) {
      return expect(resp.items.map(function (item) {
        return item.id;
      })).to.not.contain(tokenId);
    })

    // Batch account creation

    .then(function () {
      return expect(client.accounts.createBatch([{ alias: 'carol-' + uuid.v4(), rootXpubs: [otherKey.xpub], quorum: 1 }, // success
      { alias: 'david' }, { alias: 'eve-' + uuid.v4(), rootXpubs: [otherKey.xpub], quorum: 1 }])).to.be.fulfilled;
    }).then(function (batchResponse) {
      assert.equal(batchResponse.successes[1], null);
      assert.deepEqual([batchResponse.errors[0], batchResponse.errors[2]], [null, null]);
    })

    // Batch asset creation

    .then(function () {
      return expect(client.assets.createBatch([{ alias: bronzeAlias, rootXpubs: [otherKey.xpub], quorum: 1 }, // success
      { alias: 'unobtanium' }, { alias: copperAlias, rootXpubs: [otherKey.xpub], quorum: 1 }])).to.be.fulfilled;
    }).then(function (batchResponse) {
      assert.equal(batchResponse.successes[1], null);
      assert.deepEqual([batchResponse.errors[0], batchResponse.errors[2]], [null, null]);
    })

    // Basic issuance

    .then(function () {
      return expect(client.transactions.build(function (builder) {
        builder.issue({
          assetAlias: goldAlias,
          amount: 100
        });
        builder.issue({
          assetAlias: silverAlias,
          amount: 200
        });
        builder.controlWithAccount({
          accountAlias: aliceAlias,
          assetAlias: goldAlias,
          amount: 100
        });
        builder.controlWithAccount({
          accountAlias: bobAlias,
          assetAlias: silverAlias,
          amount: 200
        });
      })).to.be.fulfilled.then(function (issuance) {
        return expect(signer.sign(issuance)).to.be.fulfilled;
      }).then(function (signed) {
        return expect(client.transactions.submit(signed)).to.be.fulfilled;
      });
    }).then(function () {
      return expect(Promise.all([balanceByAssetAlias(client.balances.query({ filter: 'account_alias=\'' + aliceAlias + '\'' })), balanceByAssetAlias(client.balances.query({ filter: 'account_alias=\'' + bobAlias + '\'' }))])).to.be.fulfilled;
    }).then(function (balances) {
      assert.deepEqual(balances[0], _defineProperty({}, goldAlias, 100));
      assert.deepEqual(balances[1], _defineProperty({}, silverAlias, 200));
    })

    // Bad singleton build call

    .then(function () {
      return expect(client.transactions.build(function (builder) {
        builder.issue({
          assetAlias: 'unobtanium',
          amount: 100
        });
      }))
      // Non-existent asset
      .to.be.rejectedWith('CH002');
    })

    // Bad singleton submit call

    .then(function () {
      return expect(client.transactions.build(function (builder) {
        builder.issue({
          assetAlias: goldAlias,
          amount: 1
        });
        builder.controlWithAccount({
          accountAlias: aliceAlias,
          assetAlias: goldAlias,
          amount: 100
        });
      })).to.be.fulfilled.then(function (issuance) {
        return expect(signer.sign(issuance)).to.be.fulfilled;
      }).then(function (signed) {
        return expect(client.transactions.submit(signed))
        // unbalanced transaction
        .to.be.rejectedWith('CH735');
      });
    })

    // Atomic swap

    .then(function () {
      return expect(client.transactions.build(function (builder) {
        builder.spendFromAccount({
          accountAlias: aliceAlias,
          assetAlias: goldAlias,
          amount: 10
        });
        builder.controlWithAccount({
          accountAlias: aliceAlias,
          assetAlias: silverAlias,
          amount: 20
        });
      })).to.be.fulfilled.then(function (swapProposal) {
        swapProposal.allowAdditionalActions = true;
        return expect(signer.sign(swapProposal)).to.be.fulfilled;
      }).then(function (swapProposal) {
        return expect(client.transactions.build(function (builder) {
          builder.baseTransaction = swapProposal.rawTransaction;
          builder.spendFromAccount({
            accountAlias: bobAlias,
            assetAlias: silverAlias,
            amount: 20
          });
          builder.controlWithAccount({
            accountAlias: bobAlias,
            assetAlias: goldAlias,
            amount: 10
          });
        })).to.be.fulfilled;
      }).then(function (swapTx) {
        return expect(signer.sign(swapTx)).to.be.fulfilled;
      }).then(function (signed) {
        return expect(client.transactions.submit(signed)).to.be.fulfilled;
      });
    }).then(function () {
      return Promise.all([balanceByAssetAlias(client.balances.query({ filter: 'account_alias=\'' + aliceAlias + '\'' })), balanceByAssetAlias(client.balances.query({ filter: 'account_alias=\'' + bobAlias + '\'' }))]);
    }).then(function (balances) {
      var _assert$deepEqual3, _assert$deepEqual4;

      assert.deepEqual(balances[0], (_assert$deepEqual3 = {}, _defineProperty(_assert$deepEqual3, goldAlias, 90), _defineProperty(_assert$deepEqual3, silverAlias, 20), _assert$deepEqual3));
      assert.deepEqual(balances[1], (_assert$deepEqual4 = {}, _defineProperty(_assert$deepEqual4, goldAlias, 10), _defineProperty(_assert$deepEqual4, silverAlias, 180), _assert$deepEqual4));
    })

    // Batch transactions

    .then(function () {
      return expect(client.transactions.buildBatch([
      // Should succeed
      function (builder) {
        builder.issue({
          assetAlias: goldAlias,
          amount: 100
        });
        builder.controlWithAccount({
          accountAlias: aliceAlias,
          assetAlias: goldAlias,
          amount: 100
        });
      },

      // Should fail at the build step
      function (builder) {
        builder.issue({
          assetAlias: 'foobar'
        });
      },

      // Should fail at the submit step
      function (builder) {
        builder.issue({
          assetAlias: goldAlias,
          amount: 50
        });
        builder.controlWithAccount({
          accountAlias: aliceAlias,
          assetAlias: goldAlias,
          amount: 100
        });
      },

      // Should succeed
      function (builder) {
        builder.issue({
          assetAlias: silverAlias,
          amount: 50
        });
        builder.controlWithAccount({
          accountAlias: bobAlias,
          assetAlias: silverAlias,
          amount: 50
        });
      }])).to.be.fulfilled;
    }).then(function (buildBatch) {
      assert.equal(buildBatch.successes[1], null);
      assert.deepEqual([buildBatch.errors[0], buildBatch.errors[2], buildBatch.errors[3]], [null, null, null]);
      return expect(signer.signBatch(buildBatch.successes)).to.be.fulfilled;
    }).then(function (signedBatch) {
      assert(signedBatch.successes.indexOf(null) == -1);
      assert.deepEqual([signedBatch.errors[0], signedBatch.errors[1], signedBatch.errors[2]], [null, null, null]);
      return expect(client.transactions.submitBatch(signedBatch.successes)).to.be.fulfilled;
    }).then(function (submitBatch) {
      assert.equal(submitBatch.successes[1], null);
      assert.deepEqual([submitBatch.errors[0], submitBatch.errors[2]], [null, null]);
    })

    // Control program creation

    .then(function () {
      return expect(client.accounts.createControlProgram({ alias: aliceAlias })).to.be.fulfilled;
    }).then(function (cp) {
      return assert(cp.controlProgram);
    }).then(function () {
      return expect(client.accounts.createControlProgram({ id: aliceId })).to.be.fulfilled;
    }).then(function (cp) {
      return assert(cp.controlProgram);
    }).then(function () {
      return (
        // Empty alias/id
        expect(client.accounts.createControlProgram({})).to.be.rejectedWith('CH003')
      );
    }).then(function () {
      return (
        // Non-existent alias
        expect(client.accounts.createControlProgram({ alias: 'unobtalias' })).to.be.rejectedWith('CH002')
      );
    })

    // Pay to control program

    .then(function () {
      return expect(client.accounts.createControlProgram({ alias: aliceAlias })).to.be.fulfilled;
    }).then(function (cp) {
      return expect(client.transactions.build(function (builder) {
        builder.issue({
          assetAlias: goldAlias,
          amount: 1
        });
        builder.controlWithProgram({
          assetAlias: goldAlias,
          amount: 1,
          controlProgram: cp.controlProgram
        });
      })).to.be.fulfilled;
    }).then(function (issuance) {
      return expect(signer.sign(issuance)).to.be.fulfilled;
    }).then(function (signed) {
      return expect(client.transactions.submit(signed)).to.be.fulfilled;
    });
  });

  it('loads all results in `queryAll` requests', function () {
    var counter = 0;
    return Promise.resolve()

    // Access tokens

    .then(function () {
      return expect(Promise.all([client.accessTokens.create({ type: 'client', id: uuid.v4() }), client.accessTokens.create({ type: 'client', id: uuid.v4() })])).to.be.fulfilled;
    }).then(function () {
      counter = 0;
      return expect(client.accessTokens.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      })).to.be.fulfilled;
    }).then(function () {
      return expect(counter).to.equal(2);
    })

    // Accounts

    .then(function () {
      counter = 0;
      return expect(client.accounts.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      })).to.be.fulfilled;
    }).then(function () {
      return expect(counter).to.equal(2);
    })

    // Assets

    .then(function () {
      counter = 0;
      return expect(client.assets.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      })).to.be.fulfilled;
    }).then(function () {
      return expect(counter).to.equal(2);
    })

    // MockHsm keys

    .then(function () {
      counter = 0;
      return expect(client.mockHsm.keys.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 6 ? done() : next();
      })).to.be.fulfilled;
    }).then(function () {
      return expect(counter).to.equal(6);
    })

    // Transaction feeds

    .then(function () {
      return expect(Promise.all([client.transactionFeeds.create(), client.transactionFeeds.create()])).to.be.fulfilled;
    }).then(function () {
      counter = 0;
      return expect(client.transactionFeeds.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      })).to.be.fulfilled;
    }).then(function () {
      return expect(counter).to.equal(2);
    })

    // Transactions

    .then(function () {
      return expect(client.transactions.buildBatch([function (builder) {
        builder.issue({ assetAlias: goldAlias, amount: 1 });
        builder.controlWithAccount({ accountAlias: aliceAlias, assetAlias: goldAlias, amount: 1 });
      }, function (builder) {
        builder.issue({ assetAlias: silverAlias, amount: 1 });
        builder.controlWithAccount({ accountAlias: bobAlias, assetAlias: silverAlias, amount: 1 });
      }])).to.be.fulfilled.then(function (issuanceBatch) {
        return expect(signer.signBatch(issuanceBatch.successes)).to.be.fulfilled;
      }).then(function (signedBatch) {
        return expect(client.transactions.submitBatch(signedBatch.successes)).to.be.fulfilled;
      });
    }).then(function () {
      counter = 0;
      return expect(client.transactions.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      })).to.be.fulfilled;
    }).then(function () {
      return expect(counter).to.equal(2);
    })

    // Unspent Outputs

    .then(function () {
      counter = 0;
      return expect(client.unspentOutputs.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      })).to.be.fulfilled;
    }).then(function () {
      return expect(counter).to.equal(2);
    })

    // Balances

    .then(function () {
      counter = 0;
      return expect(client.balances.queryAll({ sumBy: ['asset_alias'] }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      })).to.be.fulfilled;
    }).then(function () {
      return expect(counter).to.equal(2);
    })

    // Rejection

    .then(function () {
      return expect(client.assets.queryAll({ pageSize: 1 }, function (item, next, done) {
        done(new Error('failure'));
      })).to.be.rejectedWith('failure');
    });
  });

  it('works with transaction feeds', function () {
    var issuanceFeed = void 0,
        spendFeed = void 0;
    var feedIssuances = [];
    var feedSpends = [];
    var submittedIssuances = [];
    var submittedSpends = [];

    return Promise.resolve().then(function () {
      return expect(client.transactionFeeds.create({
        filter: "inputs(type='issue')"
      })).to.be.fulfilled;
    }).then(function (feed) {
      issuanceFeed = feed;
    }).then(function () {
      return expect(client.transactionFeeds.create({
        filter: "inputs(type='spend')"
      })).to.be.fulfilled;
    }).then(function (feed) {
      spendFeed = feed;
    }).then(function () {
      // Monitor feeds for issuances and spends, and then build/sign/submit
      // transactions that issue and spend.
      return expect(Promise.all([issuanceFeed.consume(function (tx, next, done) {
        feedIssuances.push(tx.id);
        feedIssuances.length == 2 ? done(true) : next(true);
      }), spendFeed.consume(function (tx, next, done) {
        feedSpends.push(tx.id);
        feedSpends.length == 2 ? done(true) : next(true);
      }), Promise.resolve().then(function () {
        return buildSignSubmit(function (builder) {
          builder.issue({ assetAlias: goldAlias, amount: 1 });
          builder.controlWithAccount({ accountAlias: aliceAlias, assetAlias: goldAlias, amount: 1 });
        });
      }).then(function (tx) {
        return submittedIssuances.push(tx.id);
      }).then(function () {
        return buildSignSubmit(function (builder) {
          builder.spendFromAccount({ accountAlias: aliceAlias, assetAlias: goldAlias, amount: 1 });
          builder.controlWithAccount({ accountAlias: bobAlias, assetAlias: goldAlias, amount: 1 });
        });
      }).then(function (tx) {
        return submittedSpends.push(tx.id);
      }).then(function () {
        return buildSignSubmit(function (builder) {
          builder.issue({ assetAlias: silverAlias, amount: 1 });
          builder.controlWithAccount({ accountAlias: bobAlias, assetAlias: silverAlias, amount: 1 });
        });
      }).then(function (tx) {
        return submittedIssuances.push(tx.id);
      }).then(function () {
        return buildSignSubmit(function (builder) {
          builder.spendFromAccount({ accountAlias: bobAlias, assetAlias: silverAlias, amount: 1 });
          builder.controlWithAccount({ accountAlias: aliceAlias, assetAlias: silverAlias, amount: 1 });
        });
      }).then(function (tx) {
        return submittedSpends.push(tx.id);
      })])).to.be.fulfilled;
    }).then(function () {
      assert.deepEqual(feedIssuances, submittedIssuances);
      assert.deepEqual(feedSpends, submittedSpends);
    });
  });
});