'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-env mocha */

var chain = require('../dist/index.js');
var uuid = require('uuid');
var async = require('async');
var assert = require('assert');
var chai = require('chai');
var expect = chai.expect;

// Helper function
var balanceByAssetAlias = function balanceByAssetAlias(cb) {
  return function (err, balances) {
    var res = {};

    balances.items.forEach(function (item) {
      res[item.sumBy.assetAlias] = item.amount;
    });

    cb(null, res);
  };
};

var client = new chain.Client();
var signer = new chain.HsmSigner();

var aliceAlias = 'alice-' + uuid.v4();
var bobAlias = 'bob-' + uuid.v4();
var goldAlias = 'gold-' + uuid.v4();
var silverAlias = 'silver-' + uuid.v4();
var bronzeAlias = 'bronze-' + uuid.v4();
var copperAlias = 'copper-' + uuid.v4();
var tokenId = 'token-' + uuid.v4();

var aliceKey = void 0,
    bobKey = void 0,
    goldKey = void 0,
    silverKey = void 0,
    otherKey = void 0,
    aliceId = void 0;

describe('Callback style', function () {
  before('set up API objects', function (done) {
    async.series([
    // Key creation and signer setup

    function (next) {
      return async.parallel([function (cb) {
        return client.mockHsm.keys.create({ alias: aliceAlias }, cb);
      }, function (cb) {
        return client.mockHsm.keys.create({ alias: bobAlias }, cb);
      }, function (cb) {
        return client.mockHsm.keys.create({ alias: goldAlias }, cb);
      }, function (cb) {
        return client.mockHsm.keys.create({ alias: silverAlias }, cb);
      }, function (cb) {
        return client.mockHsm.keys.create({ alias: bronzeAlias }, cb);
      }, function (cb) {
        return client.mockHsm.keys.create({ alias: copperAlias }, cb);
      }, function (cb) {
        return client.mockHsm.keys.create({}, cb);
      }], function (err, keys) {
        expect(keys.length).to.equal(7);

        aliceKey = keys[0];
        bobKey = keys[1];
        goldKey = keys[2];
        silverKey = keys[3];
        otherKey = keys[6];

        signer.addKey(aliceKey, client.mockHsm.signerConnection);
        signer.addKey(bobKey, client.mockHsm.signerConnection);
        signer.addKey(goldKey, client.mockHsm.signerConnection);
        signer.addKey(silverKey, client.mockHsm.signerConnection);

        next();
      });
    },

    // Account creation

    function (next) {
      return async.parallel([function (cb) {
        return client.accounts.create({ alias: aliceAlias, rootXpubs: [aliceKey.xpub], quorum: 1 }, cb);
      }, function (cb) {
        return client.accounts.create({ alias: bobAlias, rootXpubs: [bobKey.xpub], quorum: 1 }, cb);
      }], function (err, accounts) {
        expect(err).to.be.null;
        aliceId = accounts[0].id;
        next();
      });
    }, function (next) {
      return client.accounts.create({ alias: 'david' }, function (err) {
        // Request is missing key fields
        expect(err.code).to.equal('CH202');
        next();
      });
    },

    // Asset creation

    function (next) {
      return async.parallel([function (cb) {
        return client.assets.create({ alias: goldAlias, rootXpubs: [goldKey.xpub], quorum: 1 }, cb);
      }, function (cb) {
        return client.assets.create({ alias: silverAlias, rootXpubs: [silverKey.xpub], quorum: 1 }, cb);
      }], function (err) {
        expect(err).to.be.null;
        next();
      });
    }, function () {
      return done();
    }]);
  });

  it('works', function (done) {

    async.series([
    // Access tokens

    function (next) {
      return client.accessTokens.create({ type: 'client', id: tokenId }, function (err, resp) {
        expect(resp.token).to.not.be.empty;
        expect(err).to.be.null;
        next();
      });
    }, function (next) {
      return client.accessTokens.create({ type: 'client', id: tokenId }, function (err, resp) {
        expect(resp).to.be.null;
        expect(err).to.not.be.null;
        expect(err.code).to.equal('CH302');
        next();
      });
    }, function (next) {
      return client.accessTokens.query({}, function (err, resp) {
        expect(err).to.be.null;
        expect(resp.items.map(function (item) {
          return item.id;
        })).to.contain(tokenId);
        next();
      });
    }, function (next) {
      return client.accessTokens.query({ type: 'client' }, function (err, resp) {
        expect(resp.items.map(function (item) {
          return item.id;
        })).to.contain(tokenId);
        next();
      });
    }, function (next) {
      return client.accessTokens.query({ type: 'network' }, function (err, resp) {
        expect(resp.items.map(function (item) {
          return item.id;
        })).to.not.contain(tokenId);
        next();
      });
    }, function (next) {
      return client.accessTokens.delete(tokenId, function (err, resp) {
        expect(resp.message).to.equal('ok');
        next();
      });
    }, function (next) {
      return client.accessTokens.query({}, function (err, resp) {
        expect(resp.items.map(function (item) {
          return item.id;
        })).to.not.contain(tokenId);
        next();
      });
    },

    // Batch account creation

    function (next) {
      return client.accounts.createBatch([{ alias: 'carol-' + uuid.v4(), rootXpubs: [otherKey.xpub], quorum: 1 }, // success
      { alias: 'david' }, { alias: 'eve-' + uuid.v4(), rootXpubs: [otherKey.xpub], quorum: 1 }], function (err, batchResponse) {
        assert.equal(batchResponse.successes[1], null);
        assert.deepEqual([batchResponse.errors[0], batchResponse.errors[2]], [null, null]);
        next();
      });
    },

    // Asset creation

    function (next) {
      return client.assets.create({ alias: 'unobtanium' }, function (err) {
        // Request is missing key fields
        expect(err.code).to.equal('CH202');
        next();
      });
    },

    // Batch asset creation

    function (next) {
      return client.assets.createBatch([{ alias: 'unobtanium' }, { alias: bronzeAlias, rootXpubs: [otherKey.xpub], quorum: 1 }, // success
      { alias: copperAlias, rootXpubs: [otherKey.xpub], quorum: 1 }], function (err, batchResponse) {
        assert.equal(batchResponse.successes[0], null);
        assert.deepEqual([batchResponse.errors[1], batchResponse.errors[2]], [null, null]);
        next();
      });
    },

    // Basic issuance

    function (next) {
      return async.waterfall([function (cb) {
        return client.transactions.build(function (builder) {
          builder.issue({
            assetAlias: goldAlias,
            amount: 100
          });
          builder.issue({
            assetAlias: silverAlias,
            amount: 200
          });
          builder.controlWithAccount({
            accountAlias: aliceAlias,
            assetAlias: goldAlias,
            amount: 100
          });
          builder.controlWithAccount({
            accountAlias: bobAlias,
            assetAlias: silverAlias,
            amount: 200
          });
        }, cb);
      }, function (issuance, cb) {
        return signer.sign(issuance, cb);
      }, function (signed, cb) {
        return client.transactions.submit(signed, cb);
      }], function (err, result) {
        expect(err).to.be.null;
        expect(result.id).to.not.be.blank;
        next();
      });
    }, function (next) {
      return async.parallel([function (cb) {
        return client.balances.query({ filter: 'account_alias=\'' + aliceAlias + '\'' }, balanceByAssetAlias(cb));
      }, function (cb) {
        return client.balances.query({ filter: 'account_alias=\'' + bobAlias + '\'' }, balanceByAssetAlias(cb));
      }], function (err, balances) {
        expect(err).to.be.null;
        assert.deepEqual(balances[0], _defineProperty({}, goldAlias, 100));
        assert.deepEqual(balances[1], _defineProperty({}, silverAlias, 200));
        next();
      });
    },

    // Bad singleton build call

    function (next) {
      return client.transactions.build(function (builder) {
        builder.issue({
          assetAlias: 'unobtanium',
          amount: 100
        });
      }, function (err) {
        // Non-existent asset
        expect(err.code).to.equal('CH002');
        next();
      });
    },

    // Bad singleton submit call

    function (next) {
      return async.waterfall([function (cb) {
        return client.transactions.build(function (builder) {
          builder.issue({
            assetAlias: goldAlias,
            amount: 1
          });
          builder.controlWithAccount({
            accountAlias: aliceAlias,
            assetAlias: goldAlias,
            amount: 100
          });
        }, cb);
      }, function (issuance, cb) {
        return signer.sign(issuance, cb);
      }, function (signed, cb) {
        return client.transactions.submit(signed, cb);
      }], function (err) {
        expect(err.code).to.equal('CH735');
        next();
      });
    },

    // Atomic swap

    function (next) {
      return async.waterfall([function (cb) {
        return client.transactions.build(function (builder) {
          builder.spendFromAccount({
            accountAlias: aliceAlias,
            assetAlias: goldAlias,
            amount: 10
          });
          builder.controlWithAccount({
            accountAlias: aliceAlias,
            assetAlias: silverAlias,
            amount: 20
          });
        }, cb);
      }, function (swapProposal, cb) {
        swapProposal.allowAdditionalActions = true;
        signer.sign(swapProposal, cb);
      }, function (swapProposal, cb) {
        return client.transactions.build(function (builder) {
          builder.baseTransaction = swapProposal.rawTransaction;
          builder.spendFromAccount({
            accountAlias: bobAlias,
            assetAlias: silverAlias,
            amount: 20
          });
          builder.controlWithAccount({
            accountAlias: bobAlias,
            assetAlias: goldAlias,
            amount: 10
          });
        }, cb);
      }, function (swapTx, cb) {
        return signer.sign(swapTx, cb);
      }, function (signed, cb) {
        return client.transactions.submit(signed, cb);
      }], function (err, result) {
        expect(err).to.be.null;
        expect(result.id).to.not.be.blank;
        next();
      });
    }, function (next) {
      return async.parallel([function (cb) {
        return client.balances.query({ filter: 'account_alias=\'' + aliceAlias + '\'' }, balanceByAssetAlias(cb));
      }, function (cb) {
        return client.balances.query({ filter: 'account_alias=\'' + bobAlias + '\'' }, balanceByAssetAlias(cb));
      }], function (err, balances) {
        var _assert$deepEqual3, _assert$deepEqual4;

        expect(err).to.be.null;
        assert.deepEqual(balances[0], (_assert$deepEqual3 = {}, _defineProperty(_assert$deepEqual3, goldAlias, 90), _defineProperty(_assert$deepEqual3, silverAlias, 20), _assert$deepEqual3));
        assert.deepEqual(balances[1], (_assert$deepEqual4 = {}, _defineProperty(_assert$deepEqual4, goldAlias, 10), _defineProperty(_assert$deepEqual4, silverAlias, 180), _assert$deepEqual4));
        next();
      });
    },

    // Batch transactions
    function (next) {
      return async.waterfall([function (cb) {
        return client.transactions.buildBatch([
        // Should succeed
        function (builder) {
          builder.issue({
            assetAlias: goldAlias,
            amount: 100
          });
          builder.controlWithAccount({
            accountAlias: aliceAlias,
            assetAlias: goldAlias,
            amount: 100
          });
        },

        // Should fail at the build step
        function (builder) {
          builder.issue({ assetAlias: 'foobar' });
        },

        // Should fail at the submit step
        function (builder) {
          builder.issue({
            assetAlias: goldAlias,
            amount: 50
          });
          builder.controlWithAccount({
            accountAlias: aliceAlias,
            assetAlias: goldAlias,
            amount: 100
          });
        },

        // Should succeed
        function (builder) {
          builder.issue({
            assetAlias: silverAlias,
            amount: 50
          });
          builder.controlWithAccount({
            accountAlias: bobAlias,
            assetAlias: silverAlias,
            amount: 50
          });
        }], cb);
      }, function (buildBatch, cb) {
        assert.equal(buildBatch.successes[1], null);
        assert.deepEqual([buildBatch.errors[0], buildBatch.errors[2], buildBatch.errors[3]], [null, null, null]);
        signer.signBatch(buildBatch.successes, cb);
      }, function (signedBatch, cb) {
        assert(signedBatch.successes.indexOf(null) == -1);
        assert.deepEqual([signedBatch.errors[0], signedBatch.errors[1], signedBatch.errors[2]], [null, null, null]);
        client.transactions.submitBatch(signedBatch.successes, cb);
      }], function (err, submitBatch) {
        assert.equal(submitBatch.successes[1], null);
        assert.deepEqual([submitBatch.errors[0], submitBatch.errors[2]], [null, null]);
        next();
      });
    },

    // Control program creation

    function (next) {
      return client.accounts.createControlProgram({ alias: aliceAlias }, function (err, cp) {
        assert(cp.controlProgram);
        next();
      });
    }, function (next) {
      return client.accounts.createControlProgram({ id: aliceId }, function (err, cp) {
        assert(cp.controlProgram);
        next();
      });
    }, function (next) {
      return client.accounts.createControlProgram({}, function (err) {
        expect(err.code).to.equal('CH003');
        next();
      });
    }, function (next) {
      return client.accounts.createControlProgram({ alias: 'unobtalias' }, function (err) {
        expect(err.code).to.equal('CH002');
        next();
      });
    },

    // Pay to control program

    function (next) {
      return async.waterfall([function (cb) {
        return client.accounts.createControlProgram({ alias: aliceAlias }, cb);
      }, function (cp, cb) {
        return client.transactions.build(function (builder) {
          builder.issue({
            assetAlias: goldAlias,
            amount: 1
          });
          builder.controlWithProgram({
            assetAlias: goldAlias,
            amount: 1,
            controlProgram: cp.controlProgram
          });
        }, cb);
      }, function (issuance, cb) {
        return signer.sign(issuance, cb);
      }, function (signed, cb) {
        return client.transactions.submit(signed, cb);
      }], function (err, submitted) {
        assert(submitted.id);
        next();
      });
    }, function () {
      return done();
    }]);
  });

  it('loads all results in `queryAll` requests', function (done) {
    var counter = 0;

    async.series([function (nextStep) {
      return async.parallel([function (cb) {
        return client.accessTokens.create({ type: 'client', id: uuid.v4() }, cb);
      }, function (cb) {
        return client.accessTokens.create({ type: 'client', id: uuid.v4() }, cb);
      }], function () {
        counter = 0;
        client.accessTokens.queryAll({ pageSize: 1 }, function (item, next, done) {
          counter += 1;
          expect(item).to.not.be.null;
          counter >= 2 ? done() : next();
        }, function () {
          expect(counter).to.equal(2);
          nextStep();
        });
      });
    },

    // Accounts

    function (nextStep) {
      counter = 0;
      client.accounts.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      }, function () {
        expect(counter).to.equal(2);
        nextStep();
      });
    },

    // Assets

    function (nextStep) {
      counter = 0;
      client.assets.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      }, function () {
        expect(counter).to.equal(2);
        nextStep();
      });
    },

    // MockHsm keys

    function (nextStep) {
      counter = 0;
      client.mockHsm.keys.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      }, function () {
        expect(counter).to.equal(2);
        nextStep();
      });
    },

    // Transaction feeds

    function (nextStep) {
      return async.parallel([function (cb) {
        return client.transactionFeeds.create({}, cb);
      }, function (cb) {
        return client.transactionFeeds.create({}, cb);
      }], function () {
        counter = 0;
        client.transactionFeeds.queryAll({ pageSize: 1 }, function (item, next, done) {
          counter += 1;
          expect(item).to.not.be.null;
          counter >= 2 ? done() : next();
        }, function () {
          expect(counter).to.equal(2);
          nextStep();
        });
      });
    },

    // Transactions

    function (nextStep) {
      return async.waterfall([function (cb) {
        return client.transactions.buildBatch([function (builder) {
          builder.issue({ assetAlias: goldAlias, amount: 100 });
          builder.controlWithAccount({ accountAlias: aliceAlias, assetAlias: goldAlias, amount: 100 });
        }, function (builder) {
          builder.issue({ assetAlias: silverAlias, amount: 100 });
          builder.controlWithAccount({ accountAlias: bobAlias, assetAlias: silverAlias, amount: 100 });
        }], cb);
      }, function (buildBatch, cb) {
        return signer.signBatch(buildBatch.successes, cb);
      }, function (signedBatch, cb) {
        return client.transactions.submitBatch(signedBatch.successes, cb);
      }], function () {
        counter = 0;
        client.transactions.queryAll({ pageSize: 1 }, function (item, next, done) {
          counter += 1;
          expect(item).to.not.be.null;
          counter >= 2 ? done() : next();
        }, function () {
          expect(counter).to.equal(2);
          nextStep();
        });
      });
    },

    // Unspent Outputs

    function (nextStep) {
      counter = 0;
      client.unspentOutputs.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      }, function () {
        expect(counter).to.equal(2);
        nextStep();
      });
    },

    // Balances

    function (nextStep) {
      counter = 0;
      client.balances.queryAll({ pageSize: 1 }, function (item, next, done) {
        counter += 1;
        expect(item).to.not.be.null;
        counter >= 2 ? done() : next();
      }, function () {
        expect(counter).to.equal(2);
        nextStep();
      });
    },

    // Rejection

    function (nextStep) {
      counter = 0;
      client.assets.queryAll({ pageSize: 1 }, function (item, next, done) {
        done(new Error('failure'));
      }, function (err) {
        expect(err.message).to.equal('failure');
        nextStep();
      });
    }, function () {
      return done();
    }]);
  });

  it('works with transaction feeds', function (done) {
    var issuanceFeed = void 0,
        spendFeed = void 0;
    var feedIssuances = [];
    var feedSpends = [];
    var submittedIssuances = [];
    var submittedSpends = [];

    async.series([function (next) {
      return client.transactionFeeds.create({
        filter: "inputs(type='issue')"
      }, function (err, feed) {
        issuanceFeed = feed;
        expect(err).to.be.null;
        next();
      });
    }, function (next) {
      return client.transactionFeeds.create({
        filter: "inputs(type='spend')"
      }, function (err, feed) {
        spendFeed = feed;
        expect(err).to.be.null;
        next();
      });
    }, function (next) {
      return async.parallel([
      // Feed consumers
      function (cb) {
        return issuanceFeed.consume(function (tx, next, done) {
          feedIssuances.push(tx.id);
          feedIssuances.length == 2 ? done(true) : next(true);
        }, function () {
          cb();
        });
      }, function (cb) {
        return spendFeed.consume(function (tx, next, done) {
          feedSpends.push(tx.id);
          feedSpends.length == 2 ? done(true) : next(true);
        }, function () {
          cb();
        });
      },

      // Transactions to read

      function (cb) {
        return async.waterfall([function (cb2) {
          return client.transactions.buildBatch([function (builder) {
            builder.issue({ assetAlias: goldAlias, amount: 1 });
            builder.controlWithAccount({ accountAlias: aliceAlias, assetAlias: goldAlias, amount: 1 });
          }, function (builder) {
            builder.issue({ assetAlias: silverAlias, amount: 1 });
            builder.controlWithAccount({ accountAlias: bobAlias, assetAlias: silverAlias, amount: 1 });
          }], cb2);
        }, function (buildBatch, cb2) {
          return signer.signBatch(buildBatch.successes, cb2);
        }, function (signedBatch, cb2) {
          return client.transactions.submitBatch(signedBatch.successes, function (err, submittedBatch) {
            submittedIssuances = submittedBatch.successes.map(function (tx) {
              return tx.id;
            });
            cb2();
          });
        }, function (cb2) {
          client.transactions.buildBatch([function (builder) {
            builder.spendFromAccount({ accountAlias: aliceAlias, assetAlias: goldAlias, amount: 1 });
            builder.controlWithAccount({ accountAlias: bobAlias, assetAlias: goldAlias, amount: 1 });
          }, function (builder) {
            builder.spendFromAccount({ accountAlias: bobAlias, assetAlias: silverAlias, amount: 1 });
            builder.controlWithAccount({ accountAlias: aliceAlias, assetAlias: silverAlias, amount: 1 });
          }], cb2);
        }, function (buildBatch, cb2) {
          return signer.signBatch(buildBatch.successes, cb2);
        }, function (signedBatch, cb2) {
          return client.transactions.submitBatch(signedBatch.successes, function (err, submittedBatch) {
            submittedSpends = submittedBatch.successes.map(function (tx) {
              return tx.id;
            });
            cb2();
          });
        }, function () {
          return cb();
        }]);
      }], function () {
        assert.deepEqual(feedIssuances.sort(), submittedIssuances.sort());
        assert.deepEqual(feedSpends.sort(), submittedSpends.sort());
        next();
      });
    }, function () {
      return done();
    }]);
  });
});