'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var shared = require('./shared');
var errors = require('./errors');

// TODO: replace with default handler in requestSingle/requestBatch variants
function checkForError(resp) {
  if ('code' in resp) {
    throw errors.create(errors.types.BAD_REQUEST, errors.formatErrMsg(resp, ''), { body: resp });
  }
  return resp;
}

/**
 * @class
 * A convenience class for building transaction template objects
 */

var TransactionBuilder = function () {
  /**
   * constructor - return a new object used for constructing a transaction.
   */
  function TransactionBuilder() {
    _classCallCheck(this, TransactionBuilder);

    this.actions = [];

    /**
     * If true, build the transaction as a partial tranaction.
     * @type {Boolean}
     */
    this.allowAdditionalActions = false;

    /**
     * Base transation provided by a third party
     * @type {Object}
     */
    this.baseTransaction = null;
  }

  /**
   * Add an action that issues assets.
   *
   * @param {Object} params - Action parameters.
   * @param {String} params.asset_id - Asset ID specifiying the asset to be issued.
   *                                   You must specify either an ID or an alias.
   * @param {String} params.asset_alias - Asset alias specifying the asset to be issued.
   *                                      You must specify either an ID or an alias.
   * @param {String} params.amount - Amount of the asset to be issued.
   */


  _createClass(TransactionBuilder, [{
    key: 'issue',
    value: function issue(params) {
      this.actions.push(Object.assign({}, params, { type: 'issue' }));
    }

    /**
     * Add an action that controls assets with an account specified by identifier.
     *
     * @param {Object} params - Action parameters.
     * @option params [String] :assetId Asset ID specifiying the asset to be controlled.
     *                                   You must specify either an ID or an alias.
     * @param {String} params.assetAlias - Asset alias specifying the asset to be controlled.
     *                                   You must specify either an ID or an alias.
     * @param {String} params.accountId - Account ID specifiying the account controlling the asset.
     *                                   You must specify either an ID or an alias.
     * @param {String} params.accountAlias - Account alias specifying the account controlling the asset.
     *                                   You must specify either an ID or an alias.
     * @param {Number} params.amount - Amount of the asset to be controlled.
     */

  }, {
    key: 'controlWithAccount',
    value: function controlWithAccount(params) {
      this.actions.push(Object.assign({}, params, { type: 'control_account' }));
    }

    /**
     * Add an action that controls assets with a control program.
     *
     * @param {Object} params - Action parameters.
     * @param {String} params.assetId - Asset ID specifiying the asset to be controlled.
     *                                   You must specify either an ID or an alias.
     * @param {String} params.assetAlias - Asset alias specifying the asset to be controlled.
     *                                   You must specify either an ID or an alias.
     * @param {String} params.controlProgram - The control program to be used
     * @param {Number} params.amount - Amount of the asset to be controlled.
     */

  }, {
    key: 'controlWithProgram',
    value: function controlWithProgram(params) {
      this.actions.push(Object.assign({}, params, { type: 'control_program' }));
    }

    /**
     * Add an action that spends assets from an account specified by identifier.
     *
     * @param {Object} params - Action parameters.
     * @param {String} params.assetId - Asset ID specifiying the asset to be spent.
     *                                   You must specify either an ID or an alias.
     * @param {String} params.assetAlias - Asset alias specifying the asset to be spent.
     *                                   You must specify either an ID or an alias.
     * @param {String} params.accountId - Account ID specifiying the account spending the asset.
     *                                   You must specify either an ID or an alias.
     * @param {String} params.accountAlias - Account alias specifying the account spending the asset.
     *                                   You must specify either an ID or an alias.
     * @param {Number} params.amount - Amount of the asset to be spent.
     */

  }, {
    key: 'spendFromAccount',
    value: function spendFromAccount(params) {
      this.actions.push(Object.assign({}, params, { type: 'spend_account' }));
    }

    /**
     * Add an action that spends an unspent output.
     *
     * @param {Object} params - Action parameters.
     * @param {String} params.transactionId - Transaction ID specifying the
     *                                        tranasction to select an output from.
     * @param {Number} params.position - Position of the output within the
     *                                   transaction to be spent.
     */

  }, {
    key: 'spendUnspentOutput',
    value: function spendUnspentOutput(params) {
      this.actions.push(Object.assign({}, params, { type: 'spend_account_unspent_output' }));
    }

    /**
     * Add an action that retires units of an assets.
     *
     * @param {Object} params - Action parameters.
     * @param {String} params.assetId - Asset ID specifiying the asset to be retired.
     *                                   You must specify either an ID or an alias.
     * @param {String} params.assetAlias - Asset alias specifying the asset to be retired.
     *                                   You must specify either an ID or an alias.
     * @param {Number} params.amount - Amount of the asset to be retired.
     */

  }, {
    key: 'retire',
    value: function retire(params) {
      this.actions.push(Object.assign({}, params, { type: 'control_program', controlProgram: '6a' }));
    }

    /**
     * transactionReferenceData - Sets the transaction-level reference data. May
     *                            only be used once per transaction.
     *
     * @param {Object} referenceData - User specified, unstructured data to
     *                                  be embedded in a transaction
     */

  }, {
    key: 'transactionReferenceData',
    value: function transactionReferenceData(referenceData) {
      this.actions.push({
        type: 'set_transaction_reference_data',
        referenceData: referenceData
      });
    }
  }]);

  return TransactionBuilder;
}();

/**
 * Processing callback for building a transaction. The instance of
 * {@link TransactionBuilder} modified in the function is used to build a transaction
 * in Chain Core.
 *
 * @callback Transactions~builderCallback
 * @param {TransactionBuilder} builder
 */

/**
 * @class
 * A blockchain consists of an immutable set of cryptographically linked
 * transactions. Each transaction contains one or more actions.
 * <br/><br/>
 * More info: {@link https://chain.com/docs/core/build-applications/transaction-basics}
 */


var Transactions =
/**
 * constructor - return Transactions object configured for specified Chain Core.
 *
 * @param {Client} client Configured Chain client object.
 */
function Transactions(client) {
  var _this = this;

  _classCallCheck(this, Transactions);

  /**
   * Get one page of transactions matching the specified query.
   *
   * @param {Query} params={} Filter and pagination information.
   * @param {pageCallback} [callback] - Optional callback. Use instead of Promise return value as desired.
   * @returns {Promise<Page>} Requested page of results.
   */
  this.query = function (params, cb) {
    return shared.query(client, _this, '/list-transactions', params, { cb: cb });
  };

  /**
   * Request all transactions matching the specified query, calling the
   * supplied processor callback with each item individually.
   *
   * @param {Query} params Filter and pagination information.
   * @param {QueryProcessor} processor Processing callback.
   * @returns {Promise} A promise resolved upon processing of all items, or
   *                   rejected on error.
   */
  this.queryAll = function (params, processor) {
    return shared.queryAll(_this, params, processor);
  };

  /**
   * Build an unsigned transaction from a set of actions.
   *
   * @param {builderCallback} builderBlock - Function that adds desired actions
   *                                         to a given builder object.
   * @param {objectCallback} [callback] - Optional callback. Use instead of Promise return value as desired.
   * @returns {Promise<Object>} - Unsigned transaction template, or error.
   */
  this.build = function (builderBlock, cb) {
    var builder = new TransactionBuilder();
    builderBlock(builder);

    return shared.tryCallback(client.request('/build-transaction', [builder]).then(function (resp) {
      return checkForError(resp[0]);
    }), cb);
  };

  /**
   * Build multiple unsigned transactions from multiple sets of actions.
   *
   * @param {Array<builderCallback>} builderBlocks - Functions that adds desired actions
   *                                                 to a given builder object, one
   *                                                 per transaction.
   * @param {objectCallback} [callback] - Optional callback. Use instead of Promise return value as desired.
   * @returns {Promise<BatchResponse>} - Batch of unsigned transaction templates, or errors.
   */
  this.buildBatch = function (builderBlocks, cb) {
    var builders = builderBlocks.map(function (builderBlock) {
      var builder = new TransactionBuilder();
      builderBlock(builder);
      return builder;
    });

    return shared.createBatch(client, '/build-transaction', builders, { cb: cb });
  };

  /**
   * Submit a signed transaction to the blockchain.
   *
   * @param {Object} signed - A fully signed transaction template.
   * @returns {Promise<Object>} Transaction ID of the successful transaction, or error.
   */
  this.submit = function (signed, cb) {
    return shared.tryCallback(client.request('/submit-transaction', { transactions: [signed] }).then(function (resp) {
      return checkForError(resp[0]);
    }), cb);
  };

  /**
   * Submit multiple signed transactions to the blockchain.
   *
   * @param {Array<Object>} signed - An array of fully signed transaction templates.
   * @returns {Promise<BatchResponse>} - Batch response of transaction IDs, or errors.
   */
  this.submitBatch = function (signed, cb) {
    return shared.tryCallback(client.request('/submit-transaction', { transactions: signed }).then(function (resp) {
      return new shared.BatchResponse(resp);
    }), cb);
  };
};

module.exports = Transactions;