'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var shared = require('./shared');

var uuid = require('uuid');
var MAX_BLOCK_HEIGHT = 2 * 63 - 1;

/**
 * @class
 * A single transaction feed that can be consumed. See {@link TransactionFeeds}
 * for actions to create TransactionFeedReader.
 * <br/><br/>
 * More info: {@link https://chain.com/docs/core/build-applications/real-time-transaction-processing}
 */

var TransactionFeedReader = function TransactionFeedReader(feed, client) {
  _classCallCheck(this, TransactionFeedReader);

  var nextAfter = void 0;
  var after = feed['after'];
  var filter = feed['filter'];
  var id = feed['id'];

  var ack = function ack() {
    return client.request('/update-transaction-feed', {
      id: id,
      after: nextAfter,
      previousAfter: after
    }).then(function () {
      after = nextAfter;
    });
  };

  var query = function query(params) {
    return client.transactions.query(params);
  };

  /**
   *
   */
  this.consume = function (consumer) {
    var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 24 * 60 * 60;

    return new Promise(function (resolve, reject) {
      var queryArgs = {
        filter: filter,
        after: after,
        timeout: timeout * 1000,
        ascendingWithLongPoll: true
      };

      var nextPage = function nextPage() {
        query(queryArgs).then(function (page) {
          var index = 0;
          var prevItem = void 0;

          var done = function done(shouldAck) {
            var p = void 0;
            if (shouldAck) {
              p = ack(prevItem);
            } else {
              p = Promise.resolve();
            }
            p.then(resolve).catch(reject);
          };

          var next = function next(shouldAck) {
            var p = void 0;
            if (shouldAck && prevItem) {
              p = ack(prevItem);
            } else {
              p = Promise.resolve();
            }

            p.then(function () {
              if (index >= page.items.length) {
                queryArgs = page.next;
                nextPage();
                return;
              }

              prevItem = page.items[index];
              nextAfter = prevItem.blockHeight + ':' + prevItem.position + '-' + MAX_BLOCK_HEIGHT;
              index++;

              // Pass the next item to the consumer, as well as three loop
              // operations:
              //
              // - next(shouldAck): maybe ack, then continue/long-poll to next item
              // - done(shouldAck): maybe ack, then terminate the loop by fulfilling the outer promise
              // - fail(err): terminate the loop by rejecting the outer promise.
              //              Use this if you want to bubble an async error up to
              //              the outer promise catch function.
              //
              // The consumer can also terminate the loop by returning a promise
              // that will reject.

              var res = consumer(prevItem, next, done, reject);
              if (res && typeof res.catch === 'function') {
                res.catch(reject);
              }
            }).catch(reject); // fail consume loop on ack failure, or on thrown exceptions from "then" function
          };

          next();
        }).catch(reject); // fail consume loop on query failure
      };

      nextPage();
    });
  };
};

/**
 * @class
 * You can use transaction feeds to process transactions as they arrive on the
 * blockchain. This is helpful for real-time applications such as notifications
 * or live-updating interfaces.
 * <br/><br/>
 * More info: {@link https://chain.com/docs/core/build-applications/real-time-transaction-processing}
 */


var TransactionFeeds =

/**
 * constructor - return TransactionFeeds object configured for specified Chain Core.
 *
 * @param {Client} client Configured Chain client object.
 */
function TransactionFeeds(client) {
  var _this = this;

  _classCallCheck(this, TransactionFeeds);

  /**
   * Create a new transaction feed.
   *
   * @param {Object} params Parameters for creating Tansaction Feeds.
   * @param {String} params.alias A unique alias for the transaction feed.
   * @param {String} params.filter A valid filter string for the `/list-transactions`
   *                               endpoint. The transaction feed will be composed of future
   *                               transactions that match the filter.
   * @returns {TransactionFeedReader}
   */
  this.create = function (params, cb) {
    var body = Object.assign({ clientToken: uuid.v4() }, params);
    return shared.tryCallback(client.request('/create-transaction-feed', body).then(function (data) {
      return new TransactionFeedReader(data, client);
    }), cb);
  };

  /**
   * Get single transaction feed given an id/alias.
   *
   * @param {Object} params Parameters to get single Tansaction Feed.
   * @param {String} params.id The unique ID of a transaction feed. Either `id` or
   *                           `alias` is required.
   * @param {String} params.alias The unique alias of a transaction feed. Either `id` or
   *                              `alias` is required.
   * @returns {TransactionFeedReader}
   */
  this.get = function (params, cb) {
    return shared.tryCallback(client.request('/get-transaction-feed', params).then(function (data) {
      return new TransactionFeedReader(data, client);
    }), cb);
  };

  /**
   * Delete a transaction feed given an id/alias.
   *
   * @param {Object} params Parameters to delete single Tansaction Feed.
   * @param {String} params.id The unique ID of a transaction feed. Either `id` or
   *                           `alias` is required.
   * @param {String} params.alias The unique alias of a transaction feed. Either `id` or
   *                              `alias` is required.
   */
  this.delete = function (params, cb) {
    return shared.tryCallback(client.request('/delete-transaction-feed', params).then(function (data) {
      return data;
    }), cb);
  };

  /**
   * Returns a page of transaction feeds defined on the core.
   */
  this.query = function (params, cb) {
    return shared.query(client, _this, '/list-transaction-feeds', params, { cb: cb });
  };
};

module.exports = TransactionFeeds;